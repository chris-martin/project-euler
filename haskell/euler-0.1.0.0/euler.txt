-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package euler
@version 0.1.0.0

module Euler.Prelude

-- | Extract the first component of a pair.
fst :: () => (a, b) -> a

-- | Extract the second component of a pair.
snd :: () => (a, b) -> b

-- | <a>otherwise</a> is defined as the value <a>True</a>. It helps to make
--   guards more readable. eg.
--   
--   <pre>
--   f x | x &lt; 0     = ...
--       | otherwise = ...
--   </pre>
otherwise :: Bool

-- | Application operator. This operator is redundant, since ordinary
--   application <tt>(f x)</tt> means the same as <tt>(f <a>$</a> x)</tt>.
--   However, <a>$</a> has low, right-associative binding precedence, so it
--   sometimes allows parentheses to be omitted; for example:
--   
--   <pre>
--   f $ g $ h x  =  f (g (h x))
--   </pre>
--   
--   It is also useful in higher-order situations, such as <tt><a>map</a>
--   (<a>$</a> 0) xs</tt>, or <tt><a>zipWith</a> (<a>$</a>) fs xs</tt>.
($) :: () => a -> b -> a -> b
infixr 0 $

-- | general coercion from integral types
fromIntegral :: (Integral a, Num b) => a -> b

-- | Conditional failure of <a>Alternative</a> computations. Defined by
--   
--   <pre>
--   guard True  = <a>pure</a> ()
--   guard False = <a>empty</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Common uses of <a>guard</a> include conditionally signaling an error
--   in an error monad and conditionally rejecting the current choice in an
--   <a>Alternative</a>-based parser.
--   
--   As an example of signaling an error in the error monad <a>Maybe</a>,
--   consider a safe division function <tt>safeDiv x y</tt> that returns
--   <a>Nothing</a> when the denominator <tt>y</tt> is zero and
--   <tt><a>Just</a> (x `div` y)</tt> otherwise. For example:
--   
--   <pre>
--   &gt;&gt;&gt; safeDiv 4 0
--   Nothing
--   &gt;&gt;&gt; safeDiv 4 2
--   Just 2
--   </pre>
--   
--   A definition of <tt>safeDiv</tt> using guards, but not <a>guard</a>:
--   
--   <pre>
--   safeDiv :: Int -&gt; Int -&gt; Maybe Int
--   safeDiv x y | y /= 0    = Just (x `div` y)
--               | otherwise = Nothing
--   </pre>
--   
--   A definition of <tt>safeDiv</tt> using <a>guard</a> and <a>Monad</a>
--   <tt>do</tt>-notation:
--   
--   <pre>
--   safeDiv :: Int -&gt; Int -&gt; Maybe Int
--   safeDiv x y = do
--     guard (y /= 0)
--     return (x `div` y)
--   </pre>
guard :: Alternative f => Bool -> f ()

-- | The <a>join</a> function is the conventional monad join operator. It
--   is used to remove one level of monadic structure, projecting its bound
--   argument into the outer level.
join :: Monad m => m m a -> m a

-- | The <a>Eq</a> class defines equality (<a>==</a>) and inequality
--   (<a>/=</a>). All the basic datatypes exported by the <a>Prelude</a>
--   are instances of <a>Eq</a>, and <a>Eq</a> may be derived for any
--   datatype whose constituents are also instances of <a>Eq</a>.
--   
--   Minimal complete definition: either <a>==</a> or <a>/=</a>.
class Eq a
(==) :: Eq a => a -> a -> Bool
(/=) :: Eq a => a -> a -> Bool

-- | Trigonometric and hyperbolic functions and related functions.
class Fractional a => Floating a
pi :: Floating a => a
exp :: Floating a => a -> a
log :: Floating a => a -> a
sqrt :: Floating a => a -> a
(**) :: Floating a => a -> a -> a
logBase :: Floating a => a -> a -> a
sin :: Floating a => a -> a
cos :: Floating a => a -> a
tan :: Floating a => a -> a
asin :: Floating a => a -> a
acos :: Floating a => a -> a
atan :: Floating a => a -> a
sinh :: Floating a => a -> a
cosh :: Floating a => a -> a
tanh :: Floating a => a -> a
asinh :: Floating a => a -> a
acosh :: Floating a => a -> a
atanh :: Floating a => a -> a

-- | Fractional numbers, supporting real division.
class Num a => Fractional a

-- | fractional division
(/) :: Fractional a => a -> a -> a

-- | reciprocal fraction
recip :: Fractional a => a -> a

-- | Conversion from a <a>Rational</a> (that is <tt><a>Ratio</a>
--   <a>Integer</a></tt>). A floating literal stands for an application of
--   <a>fromRational</a> to a value of type <a>Rational</a>, so such
--   literals have type <tt>(<a>Fractional</a> a) =&gt; a</tt>.
fromRational :: Fractional a => Rational -> a

-- | Integral numbers, supporting integer division.
class (Real a, Enum a) => Integral a

-- | integer division truncated toward zero
quot :: Integral a => a -> a -> a

-- | integer remainder, satisfying
--   
--   <pre>
--   (x `quot` y)*y + (x `rem` y) == x
--   </pre>
rem :: Integral a => a -> a -> a

-- | integer division truncated toward negative infinity
div :: Integral a => a -> a -> a

-- | integer modulus, satisfying
--   
--   <pre>
--   (x `div` y)*y + (x `mod` y) == x
--   </pre>
mod :: Integral a => a -> a -> a

-- | simultaneous <a>quot</a> and <a>rem</a>
quotRem :: Integral a => a -> a -> (a, a)

-- | simultaneous <a>div</a> and <a>mod</a>
divMod :: Integral a => a -> a -> (a, a)

-- | conversion to <a>Integer</a>
toInteger :: Integral a => a -> Integer

-- | The <a>Monad</a> class defines the basic operations over a
--   <i>monad</i>, a concept from a branch of mathematics known as
--   <i>category theory</i>. From the perspective of a Haskell programmer,
--   however, it is best to think of a monad as an <i>abstract datatype</i>
--   of actions. Haskell's <tt>do</tt> expressions provide a convenient
--   syntax for writing monadic expressions.
--   
--   Instances of <a>Monad</a> should satisfy the following laws:
--   
--   <ul>
--   <li><pre><a>return</a> a <a>&gt;&gt;=</a> k = k a</pre></li>
--   <li><pre>m <a>&gt;&gt;=</a> <a>return</a> = m</pre></li>
--   <li><pre>m <a>&gt;&gt;=</a> (\x -&gt; k x <a>&gt;&gt;=</a> h) = (m
--   <a>&gt;&gt;=</a> k) <a>&gt;&gt;=</a> h</pre></li>
--   </ul>
--   
--   Furthermore, the <a>Monad</a> and <a>Applicative</a> operations should
--   relate as follows:
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>(<a>&lt;*&gt;</a>) = <a>ap</a></pre></li>
--   </ul>
--   
--   The above laws imply:
--   
--   <ul>
--   <li><pre><a>fmap</a> f xs = xs <a>&gt;&gt;=</a> <a>return</a> .
--   f</pre></li>
--   <li><pre>(<a>&gt;&gt;</a>) = (<a>*&gt;</a>)</pre></li>
--   </ul>
--   
--   and that <a>pure</a> and (<a>&lt;*&gt;</a>) satisfy the applicative
--   functor laws.
--   
--   The instances of <a>Monad</a> for lists, <a>Maybe</a> and <a>IO</a>
--   defined in the <a>Prelude</a> satisfy these laws.
class Applicative m => Monad (m :: * -> *)

-- | Sequentially compose two actions, passing any value produced by the
--   first as an argument to the second.
(>>=) :: Monad m => m a -> a -> m b -> m b

-- | Sequentially compose two actions, discarding any value produced by the
--   first, like sequencing operators (such as the semicolon) in imperative
--   languages.
(>>) :: Monad m => m a -> m b -> m b

-- | Inject a value into the monadic type.
return :: Monad m => a -> m a

-- | Fail with a message. This operation is not part of the mathematical
--   definition of a monad, but is invoked on pattern-match failure in a
--   <tt>do</tt> expression.
--   
--   As part of the MonadFail proposal (MFP), this function is moved to its
--   own class <tt>MonadFail</tt> (see <a>Control.Monad.Fail</a> for more
--   details). The definition here will be removed in a future release.
fail :: Monad m => String -> m a

-- | The <a>Functor</a> class is used for types that can be mapped over.
--   Instances of <a>Functor</a> should satisfy the following laws:
--   
--   <pre>
--   fmap id  ==  id
--   fmap (f . g)  ==  fmap f . fmap g
--   </pre>
--   
--   The instances of <a>Functor</a> for lists, <a>Maybe</a> and <a>IO</a>
--   satisfy these laws.
class Functor (f :: * -> *)
fmap :: Functor f => a -> b -> f a -> f b

-- | Replace all locations in the input with the same value. The default
--   definition is <tt><a>fmap</a> . <a>const</a></tt>, but this may be
--   overridden with a more efficient version.
(<$) :: Functor f => a -> f b -> f a

-- | Basic numeric class.
class Num a
(+) :: Num a => a -> a -> a
(-) :: Num a => a -> a -> a
(*) :: Num a => a -> a -> a

-- | Unary negation.
negate :: Num a => a -> a

-- | Absolute value.
abs :: Num a => a -> a

-- | Sign of a number. The functions <a>abs</a> and <a>signum</a> should
--   satisfy the law:
--   
--   <pre>
--   abs x * signum x == x
--   </pre>
--   
--   For real numbers, the <a>signum</a> is either <tt>-1</tt> (negative),
--   <tt>0</tt> (zero) or <tt>1</tt> (positive).
signum :: Num a => a -> a

-- | Conversion from an <a>Integer</a>. An integer literal represents the
--   application of the function <a>fromInteger</a> to the appropriate
--   value of type <a>Integer</a>, so such literals have type
--   <tt>(<a>Num</a> a) =&gt; a</tt>.
fromInteger :: Num a => Integer -> a

-- | The <a>Ord</a> class is used for totally ordered datatypes.
--   
--   Instances of <a>Ord</a> can be derived for any user-defined datatype
--   whose constituent types are in <a>Ord</a>. The declared order of the
--   constructors in the data declaration determines the ordering in
--   derived <a>Ord</a> instances. The <a>Ordering</a> datatype allows a
--   single comparison to determine the precise ordering of two objects.
--   
--   Minimal complete definition: either <a>compare</a> or <a>&lt;=</a>.
--   Using <a>compare</a> can be more efficient for complex types.
class Eq a => Ord a
compare :: Ord a => a -> a -> Ordering
(<) :: Ord a => a -> a -> Bool
(<=) :: Ord a => a -> a -> Bool
(>) :: Ord a => a -> a -> Bool
(>=) :: Ord a => a -> a -> Bool
max :: Ord a => a -> a -> a
min :: Ord a => a -> a -> a

-- | Extracting components of fractions.
class (Real a, Fractional a) => RealFrac a

-- | The function <a>properFraction</a> takes a real fractional number
--   <tt>x</tt> and returns a pair <tt>(n,f)</tt> such that <tt>x =
--   n+f</tt>, and:
--   
--   <ul>
--   <li><tt>n</tt> is an integral number with the same sign as <tt>x</tt>;
--   and</li>
--   <li><tt>f</tt> is a fraction with the same type and sign as
--   <tt>x</tt>, and with absolute value less than <tt>1</tt>.</li>
--   </ul>
--   
--   The default definitions of the <a>ceiling</a>, <a>floor</a>,
--   <a>truncate</a> and <a>round</a> functions are in terms of
--   <a>properFraction</a>.
properFraction :: (RealFrac a, Integral b) => a -> (b, a)

-- | <tt><a>truncate</a> x</tt> returns the integer nearest <tt>x</tt>
--   between zero and <tt>x</tt>
truncate :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>round</a> x</tt> returns the nearest integer to <tt>x</tt>; the
--   even integer if <tt>x</tt> is equidistant between two integers
round :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>ceiling</a> x</tt> returns the least integer not less than
--   <tt>x</tt>
ceiling :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>floor</a> x</tt> returns the greatest integer not greater than
--   <tt>x</tt>
floor :: (RealFrac a, Integral b) => a -> b

-- | Conversion of values to readable <a>String</a>s.
--   
--   Derived instances of <a>Show</a> have the following properties, which
--   are compatible with derived instances of <a>Read</a>:
--   
--   <ul>
--   <li>The result of <a>show</a> is a syntactically correct Haskell
--   expression containing only constants, given the fixity declarations in
--   force at the point where the type is declared. It contains only the
--   constructor names defined in the data type, parentheses, and spaces.
--   When labelled constructor fields are used, braces, commas, field
--   names, and equal signs are also used.</li>
--   <li>If the constructor is defined to be an infix operator, then
--   <a>showsPrec</a> will produce infix applications of the
--   constructor.</li>
--   <li>the representation will be enclosed in parentheses if the
--   precedence of the top-level constructor in <tt>x</tt> is less than
--   <tt>d</tt> (associativity is ignored). Thus, if <tt>d</tt> is
--   <tt>0</tt> then the result is never surrounded in parentheses; if
--   <tt>d</tt> is <tt>11</tt> it is always surrounded in parentheses,
--   unless it is an atomic expression.</li>
--   <li>If the constructor is defined using record syntax, then
--   <a>show</a> will produce the record-syntax form, with the fields given
--   in the same order as the original declaration.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Show</a> is equivalent to
--   
--   <pre>
--   instance (Show a) =&gt; Show (Tree a) where
--   
--          showsPrec d (Leaf m) = showParen (d &gt; app_prec) $
--               showString "Leaf " . showsPrec (app_prec+1) m
--            where app_prec = 10
--   
--          showsPrec d (u :^: v) = showParen (d &gt; up_prec) $
--               showsPrec (up_prec+1) u .
--               showString " :^: "      .
--               showsPrec (up_prec+1) v
--            where up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is ignored. For example,
--   
--   <ul>
--   <li><tt><a>show</a> (Leaf 1 :^: Leaf 2 :^: Leaf 3)</tt> produces the
--   string <tt>"Leaf 1 :^: (Leaf 2 :^: Leaf 3)"</tt>.</li>
--   </ul>
class Show a

-- | Convert a value to a readable <a>String</a>.
--   
--   <a>showsPrec</a> should satisfy the law
--   
--   <pre>
--   showsPrec d x r ++ s  ==  showsPrec d x (r ++ s)
--   </pre>
--   
--   Derived instances of <a>Read</a> and <a>Show</a> satisfy the
--   following:
--   
--   <ul>
--   <li><tt>(x,"")</tt> is an element of <tt>(<a>readsPrec</a> d
--   (<a>showsPrec</a> d x ""))</tt>.</li>
--   </ul>
--   
--   That is, <a>readsPrec</a> parses the string produced by
--   <a>showsPrec</a>, and delivers the value that <a>showsPrec</a> started
--   with.
showsPrec :: Show a => Int -> a -> ShowS

-- | A specialised variant of <a>showsPrec</a>, using precedence context
--   zero, and returning an ordinary <a>String</a>.
show :: Show a => a -> String

-- | The method <a>showList</a> is provided to allow the programmer to give
--   a specialised way of showing lists of values. For example, this is
--   used by the predefined <a>Show</a> instance of the <a>Char</a> type,
--   where values of type <a>String</a> should be shown in double quotes,
--   rather than between square brackets.
showList :: Show a => [a] -> ShowS

-- | A functor with application, providing operations to
--   
--   <ul>
--   <li>embed pure expressions (<a>pure</a>), and</li>
--   <li>sequence computations and combine their results (<a>&lt;*&gt;</a>
--   and <a>liftA2</a>).</li>
--   </ul>
--   
--   A minimal complete definition must include implementations of
--   <a>pure</a> and of either <a>&lt;*&gt;</a> or <a>liftA2</a>. If it
--   defines both, then they must behave the same as their default
--   definitions:
--   
--   <pre>
--   (<a>&lt;*&gt;</a>) = <a>liftA2</a> <a>id</a>
--   </pre>
--   
--   <pre>
--   <a>liftA2</a> f x y = f <tt>&lt;$&gt;</tt> x <a>&lt;*&gt;</a> y
--   </pre>
--   
--   Further, any definition must satisfy the following:
--   
--   <ul>
--   <li><i><i>identity</i></i> <pre><a>pure</a> <a>id</a> <a>&lt;*&gt;</a>
--   v = v</pre></li>
--   <li><i><i>composition</i></i> <pre><a>pure</a> (.) <a>&lt;*&gt;</a> u
--   <a>&lt;*&gt;</a> v <a>&lt;*&gt;</a> w = u <a>&lt;*&gt;</a> (v
--   <a>&lt;*&gt;</a> w)</pre></li>
--   <li><i><i>homomorphism</i></i> <pre><a>pure</a> f <a>&lt;*&gt;</a>
--   <a>pure</a> x = <a>pure</a> (f x)</pre></li>
--   <li><i><i>interchange</i></i> <pre>u <a>&lt;*&gt;</a> <a>pure</a> y =
--   <a>pure</a> (<a>$</a> y) <a>&lt;*&gt;</a> u</pre></li>
--   </ul>
--   
--   The other methods have the following default definitions, which may be
--   overridden with equivalent specialized implementations:
--   
--   <ul>
--   <li><pre>u <a>*&gt;</a> v = (<a>id</a> <a>&lt;$</a> u)
--   <a>&lt;*&gt;</a> v</pre></li>
--   <li><pre>u <a>&lt;*</a> v = <a>liftA2</a> <a>const</a> u v</pre></li>
--   </ul>
--   
--   As a consequence of these laws, the <a>Functor</a> instance for
--   <tt>f</tt> will satisfy
--   
--   <ul>
--   <li><pre><a>fmap</a> f x = <a>pure</a> f <a>&lt;*&gt;</a> x</pre></li>
--   </ul>
--   
--   It may be useful to note that supposing
--   
--   <pre>
--   forall x y. p (q x y) = f x . g y
--   </pre>
--   
--   it follows from the above that
--   
--   <pre>
--   <a>liftA2</a> p (<a>liftA2</a> q u v) = <a>liftA2</a> f u . <a>liftA2</a> g v
--   </pre>
--   
--   If <tt>f</tt> is also a <a>Monad</a>, it should satisfy
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>(<a>&lt;*&gt;</a>) = <a>ap</a></pre></li>
--   <li><pre>(<a>*&gt;</a>) = (<a>&gt;&gt;</a>)</pre></li>
--   </ul>
--   
--   (which implies that <a>pure</a> and <a>&lt;*&gt;</a> satisfy the
--   applicative functor laws).
class Functor f => Applicative (f :: * -> *)

-- | Lift a value.
pure :: Applicative f => a -> f a

-- | Sequential application.
--   
--   A few functors support an implementation of <a>&lt;*&gt;</a> that is
--   more efficient than the default one.
(<*>) :: Applicative f => f a -> b -> f a -> f b

-- | Lift a binary function to actions.
--   
--   Some functors support an implementation of <a>liftA2</a> that is more
--   efficient than the default one. In particular, if <a>fmap</a> is an
--   expensive operation, it is likely better to use <a>liftA2</a> than to
--   <a>fmap</a> over the structure and then use <a>&lt;*&gt;</a>.
liftA2 :: Applicative f => a -> b -> c -> f a -> f b -> f c

-- | Sequence actions, discarding the value of the first argument.
(*>) :: Applicative f => f a -> f b -> f b

-- | Sequence actions, discarding the value of the second argument.
(<*) :: Applicative f => f a -> f b -> f a

-- | Data structures that can be folded.
--   
--   For example, given a data type
--   
--   <pre>
--   data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)
--   </pre>
--   
--   a suitable instance would be
--   
--   <pre>
--   instance Foldable Tree where
--      foldMap f Empty = mempty
--      foldMap f (Leaf x) = f x
--      foldMap f (Node l k r) = foldMap f l `mappend` f k `mappend` foldMap f r
--   </pre>
--   
--   This is suitable even for abstract types, as the monoid is assumed to
--   satisfy the monoid laws. Alternatively, one could define
--   <tt>foldr</tt>:
--   
--   <pre>
--   instance Foldable Tree where
--      foldr f z Empty = z
--      foldr f z (Leaf x) = f x z
--      foldr f z (Node l k r) = foldr f (f k (foldr f z r)) l
--   </pre>
--   
--   <tt>Foldable</tt> instances are expected to satisfy the following
--   laws:
--   
--   <pre>
--   foldr f z t = appEndo (foldMap (Endo . f) t ) z
--   </pre>
--   
--   <pre>
--   foldl f z t = appEndo (getDual (foldMap (Dual . Endo . flip f) t)) z
--   </pre>
--   
--   <pre>
--   fold = foldMap id
--   </pre>
--   
--   <pre>
--   length = getSum . foldMap (Sum . const  1)
--   </pre>
--   
--   <tt>sum</tt>, <tt>product</tt>, <tt>maximum</tt>, and <tt>minimum</tt>
--   should all be essentially equivalent to <tt>foldMap</tt> forms, such
--   as
--   
--   <pre>
--   sum = getSum . foldMap Sum
--   </pre>
--   
--   but may be less defined.
--   
--   If the type is also a <a>Functor</a> instance, it should satisfy
--   
--   <pre>
--   foldMap f = fold . fmap f
--   </pre>
--   
--   which implies that
--   
--   <pre>
--   foldMap f . fmap g = foldMap (f . g)
--   </pre>
class Foldable (t :: * -> *)

-- | Combine the elements of a structure using a monoid.
fold :: (Foldable t, Monoid m) => t m -> m

-- | Map each element of the structure to a monoid, and combine the
--   results.
foldMap :: (Foldable t, Monoid m) => a -> m -> t a -> m

-- | Right-associative fold of a structure, but with strict application of
--   the operator.
foldr' :: Foldable t => a -> b -> b -> b -> t a -> b

-- | Left-associative fold of a structure.
--   
--   In the case of lists, <a>foldl</a>, when applied to a binary operator,
--   a starting value (typically the left-identity of the operator), and a
--   list, reduces the list using the binary operator, from left to right:
--   
--   <pre>
--   foldl f z [x1, x2, ..., xn] == (...((z `f` x1) `f` x2) `f`...) `f` xn
--   </pre>
--   
--   Note that to produce the outermost application of the operator the
--   entire input list must be traversed. This means that <a>foldl'</a>
--   will diverge if given an infinite list.
--   
--   Also note that if you want an efficient left-fold, you probably want
--   to use <a>foldl'</a> instead of <a>foldl</a>. The reason for this is
--   that latter does not force the "inner" results (e.g. <tt>z <tt>f</tt>
--   x1</tt> in the above example) before applying them to the operator
--   (e.g. to <tt>(<tt>f</tt> x2)</tt>). This results in a thunk chain
--   <tt>O(n)</tt> elements long, which then must be evaluated from the
--   outside-in.
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldl f z = <a>foldl</a> f z . <a>toList</a>
--   </pre>
foldl :: Foldable t => b -> a -> b -> b -> t a -> b

-- | Left-associative fold of a structure but with strict application of
--   the operator.
--   
--   This ensures that each step of the fold is forced to weak head normal
--   form before being applied, avoiding the collection of thunks that
--   would otherwise occur. This is often what you want to strictly reduce
--   a finite list to a single, monolithic result (e.g. <a>length</a>).
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldl f z = <a>foldl'</a> f z . <a>toList</a>
--   </pre>
foldl' :: Foldable t => b -> a -> b -> b -> t a -> b

-- | List of elements of a structure, from left to right.
toList :: Foldable t => t a -> [a]

-- | Map each element of a structure to an action, evaluate these actions
--   from left to right, and collect the results. For a version that
--   ignores the results see <a>traverse_</a>.
traverse :: (Traversable t, Applicative f) => a -> f b -> t a -> f t b

-- | Evaluate each action in the structure from left to right, and and
--   collect the results. For a version that ignores the results see
--   <a>sequenceA_</a>.
sequenceA :: (Traversable t, Applicative f) => t f a -> f t a

-- | The class of semigroups (types with an associative binary operation).
--   
--   Instances should satisfy the associativity law:
--   
--   <ul>
--   <li><pre>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) = (x <a>&lt;&gt;</a>
--   y) <a>&lt;&gt;</a> z</pre></li>
--   </ul>
class Semigroup a

-- | An associative operation.
(<>) :: Semigroup a => a -> a -> a

-- | Reduce a non-empty list with <tt>&lt;&gt;</tt>
--   
--   The default definition should be sufficient, but this can be
--   overridden for efficiency.
sconcat :: Semigroup a => NonEmpty a -> a

-- | Repeat a value <tt>n</tt> times.
--   
--   Given that this works on a <a>Semigroup</a> it is allowed to fail if
--   you request 0 or fewer repetitions, and the default definition will do
--   so.
--   
--   By making this a member of the class, idempotent semigroups and
--   monoids can upgrade this to execute in <i>O(1)</i> by picking
--   <tt>stimes = <tt>stimesIdempotent</tt></tt> or <tt>stimes =
--   <a>stimesIdempotentMonoid</a></tt> respectively.
stimes :: (Semigroup a, Integral b) => b -> a -> a

-- | The class of monoids (types with an associative binary operation that
--   has an identity). Instances should satisfy the following laws:
--   
--   <ul>
--   <li><pre>x <a>&lt;&gt;</a> <a>mempty</a> = x</pre></li>
--   <li><pre><a>mempty</a> <a>&lt;&gt;</a> x = x</pre></li>
--   <li><tt>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) = (x <a>&lt;&gt;</a>
--   y) <a>&lt;&gt;</a> z</tt> (<a>Semigroup</a> law)</li>
--   <li><pre><a>mconcat</a> = <a>foldr</a> '(&lt;&gt;)'
--   <a>mempty</a></pre></li>
--   </ul>
--   
--   The method names refer to the monoid of lists under concatenation, but
--   there are many other instances.
--   
--   Some types can be viewed as a monoid in more than one way, e.g. both
--   addition and multiplication on numbers. In such cases we often define
--   <tt>newtype</tt>s and make those instances of <a>Monoid</a>, e.g.
--   <tt>Sum</tt> and <tt>Product</tt>.
--   
--   <b>NOTE</b>: <a>Semigroup</a> is a superclass of <a>Monoid</a> since
--   <i>base-4.11.0.0</i>.
class Semigroup a => Monoid a

-- | Identity of <a>mappend</a>
mempty :: Monoid a => a

-- | An associative operation
--   
--   <b>NOTE</b>: This method is redundant and has the default
--   implementation <tt><a>mappend</a> = '(&lt;&gt;)'</tt> since
--   <i>base-4.11.0.0</i>.
mappend :: Monoid a => a -> a -> a

-- | Fold a list using the monoid.
--   
--   For most types, the default definition for <a>mconcat</a> will be
--   used, but the function is included in the class definition so that an
--   optimized version can be provided for specific types.
mconcat :: Monoid a => [a] -> a
data Bool
False :: Bool
True :: Bool

-- | The character type <a>Char</a> is an enumeration whose values
--   represent Unicode (or equivalently ISO/IEC 10646) code points (i.e.
--   characters, see <a>http://www.unicode.org/</a> for details). This set
--   extends the ISO 8859-1 (Latin-1) character set (the first 256
--   characters), which is itself an extension of the ASCII character set
--   (the first 128 characters). A character literal in Haskell has type
--   <a>Char</a>.
--   
--   To convert a <a>Char</a> to or from the corresponding <a>Int</a> value
--   defined by Unicode, use <a>toEnum</a> and <a>fromEnum</a> from the
--   <a>Enum</a> class respectively (or equivalently <tt>ord</tt> and
--   <tt>chr</tt>).
data Char

-- | Double-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   double-precision type.
data Double

-- | A fixed-precision integer type with at least the range <tt>[-2^29 ..
--   2^29-1]</tt>. The exact range for a given implementation can be
--   determined by using <a>minBound</a> and <a>maxBound</a> from the
--   <a>Bounded</a> class.
data Int

-- | Invariant: <a>Jn#</a> and <a>Jp#</a> are used iff value doesn't fit in
--   <a>S#</a>
--   
--   Useful properties resulting from the invariants:
--   
--   <ul>
--   <li><pre>abs (<a>S#</a> _) &lt;= abs (<a>Jp#</a> _)</pre></li>
--   <li><pre>abs (<a>S#</a> _) &lt; abs (<a>Jn#</a> _)</pre></li>
--   </ul>
data Integer

-- | Type representing arbitrary-precision non-negative integers.
--   
--   <pre>
--   &gt;&gt;&gt; 2^20 :: Natural
--   1267650600228229401496703205376
--   </pre>
--   
--   Operations whose result would be negative <tt><tt>throw</tt>
--   (<tt>Underflow</tt> :: <tt>ArithException</tt>)</tt>,
--   
--   <pre>
--   &gt;&gt;&gt; -1 :: Natural
--   *** Exception: arithmetic underflow
--   </pre>
data Natural

-- | The <a>Maybe</a> type encapsulates an optional value. A value of type
--   <tt><a>Maybe</a> a</tt> either contains a value of type <tt>a</tt>
--   (represented as <tt><a>Just</a> a</tt>), or it is empty (represented
--   as <a>Nothing</a>). Using <a>Maybe</a> is a good way to deal with
--   errors or exceptional cases without resorting to drastic measures such
--   as <a>error</a>.
--   
--   The <a>Maybe</a> type is also a monad. It is a simple kind of error
--   monad, where all errors are represented by <a>Nothing</a>. A richer
--   error monad can be built using the <a>Either</a> type.
data Maybe a
Nothing :: Maybe a
Just :: a -> Maybe a
data Ordering
LT :: Ordering
EQ :: Ordering
GT :: Ordering

-- | Rational numbers, with numerator and denominator of some
--   <a>Integral</a> type.
data Ratio a

-- | Arbitrary-precision rational numbers, represented as a ratio of two
--   <a>Integer</a> values. A rational number may be constructed using the
--   <a>%</a> operator.
type Rational = Ratio Integer

-- | A value of type <tt><a>IO</a> a</tt> is a computation which, when
--   performed, does some I/O before returning a value of type <tt>a</tt>.
--   
--   There is really only one way to "perform" an I/O action: bind it to
--   <tt>Main.main</tt> in your program. When your program is run, the I/O
--   will be performed. It isn't possible to perform I/O from an arbitrary
--   function, unless that function is itself in the <a>IO</a> monad and
--   called at some point, directly or indirectly, from <tt>Main.main</tt>.
--   
--   <a>IO</a> is a monad, so <a>IO</a> actions can be combined using
--   either the do-notation or the <tt>&gt;&gt;</tt> and <tt>&gt;&gt;=</tt>
--   operations from the <tt>Monad</tt> class.
data IO a

-- | The <a>Either</a> type represents values with two possibilities: a
--   value of type <tt><a>Either</a> a b</tt> is either <tt><a>Left</a>
--   a</tt> or <tt><a>Right</a> b</tt>.
--   
--   The <a>Either</a> type is sometimes used to represent a value which is
--   either correct or an error; by convention, the <a>Left</a> constructor
--   is used to hold an error value and the <a>Right</a> constructor is
--   used to hold a correct value (mnemonic: "right" also means "correct").
--   
--   <h4><b>Examples</b></h4>
--   
--   The type <tt><a>Either</a> <a>String</a> <a>Int</a></tt> is the type
--   of values which can be either a <a>String</a> or an <a>Int</a>. The
--   <a>Left</a> constructor can be used only on <a>String</a>s, and the
--   <a>Right</a> constructor can be used only on <a>Int</a>s:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; s
--   Left "foo"
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; n
--   Right 3
--   
--   &gt;&gt;&gt; :type s
--   s :: Either String Int
--   
--   &gt;&gt;&gt; :type n
--   n :: Either String Int
--   </pre>
--   
--   The <a>fmap</a> from our <a>Functor</a> instance will ignore
--   <a>Left</a> values, but will apply the supplied function to values
--   contained in a <a>Right</a>:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; fmap (*2) s
--   Left "foo"
--   
--   &gt;&gt;&gt; fmap (*2) n
--   Right 6
--   </pre>
--   
--   The <a>Monad</a> instance for <a>Either</a> allows us to chain
--   together multiple actions which may fail, and fail overall if any of
--   the individual steps failed. First we'll write a function that can
--   either parse an <a>Int</a> from a <a>Char</a>, or fail.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char ( digitToInt, isDigit )
--   
--   &gt;&gt;&gt; :{
--       let parseEither :: Char -&gt; Either String Int
--           parseEither c
--             | isDigit c = Right (digitToInt c)
--             | otherwise = Left "parse error"
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   The following should work, since both <tt>'1'</tt> and <tt>'2'</tt>
--   can be parsed as <a>Int</a>s.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither '1'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Right 3
--   </pre>
--   
--   But the following should fail overall, since the first operation where
--   we attempt to parse <tt>'m'</tt> as an <a>Int</a> will fail:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither 'm'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Left "parse error"
--   </pre>
data Either a b
Left :: a -> Either a b
Right :: b -> Either a b

-- | Map over both arguments at the same time.
--   
--   <pre>
--   <a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; bimap toUpper (+1) ('j', 3)
--   ('J',4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bimap toUpper (+1) (Left 'j')
--   Left 'J'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bimap toUpper (+1) (Right 3)
--   Right 4
--   </pre>
bimap :: Bifunctor p => a -> b -> c -> d -> p a c -> p b d

-- | <a>nonEmpty</a> efficiently turns a normal list into a <a>NonEmpty</a>
--   stream, producing <a>Nothing</a> if the input is empty.
nonEmpty :: () => [a] -> Maybe NonEmpty a

-- | Fanout: send the input to both argument arrows and combine their
--   output.
--   
--   The default definition may be overridden with a more efficient version
--   if desired.
(&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
infixr 3 &&&

-- | The <a>find</a> function takes a predicate and a structure and returns
--   the leftmost element of the structure matching the predicate, or
--   <a>Nothing</a> if there is no such element.
find :: Foldable t => a -> Bool -> t a -> Maybe a

-- | The largest element of a non-empty structure with respect to the given
--   comparison function.
maximumBy :: Foldable t => a -> a -> Ordering -> t a -> a

-- | The <a>sort</a> function implements a stable sorting algorithm. It is
--   a special case of <a>sortBy</a>, which allows the programmer to supply
--   their own comparison function.
--   
--   Elements are arranged from from lowest to highest, keeping duplicates
--   in the order they appeared in the input.
--   
--   <pre>
--   &gt;&gt;&gt; sort [1,6,4,3,2,5]
--   [1,2,3,4,5,6]
--   </pre>
sort :: Ord a => [a] -> [a]

-- | The <a>permutations</a> function returns the list of all permutations
--   of the argument.
--   
--   <pre>
--   &gt;&gt;&gt; permutations "abc"
--   ["abc","bac","cba","bca","cab","acb"]
--   </pre>
permutations :: () => [a] -> [[a]]

-- | The <a>inits</a> function returns all initial segments of the
--   argument, shortest first. For example,
--   
--   <pre>
--   &gt;&gt;&gt; inits "abc"
--   ["","a","ab","abc"]
--   </pre>
--   
--   Note that <a>inits</a> has the following strictness property:
--   <tt>inits (xs ++ _|_) = inits xs ++ _|_</tt>
--   
--   In particular, <tt>inits _|_ = [] : _|_</tt>
inits :: () => [a] -> [[a]]

-- | The <a>group</a> function takes a list and returns a list of lists
--   such that the concatenation of the result is equal to the argument.
--   Moreover, each sublist in the result contains only equal elements. For
--   example,
--   
--   <pre>
--   &gt;&gt;&gt; group "Mississippi"
--   ["M","i","ss","i","ss","i","pp","i"]
--   </pre>
--   
--   It is a special case of <a>groupBy</a>, which allows the programmer to
--   supply their own equality test.
group :: Eq a => [a] -> [[a]]

-- | <a>intercalate</a> <tt>xs xss</tt> is equivalent to <tt>(<a>concat</a>
--   (<a>intersperse</a> xs xss))</tt>. It inserts the list <tt>xs</tt> in
--   between the lists in <tt>xss</tt> and concatenates the result.
--   
--   <pre>
--   &gt;&gt;&gt; intercalate ", " ["Lorem", "ipsum", "dolor"]
--   "Lorem, ipsum, dolor"
--   </pre>
intercalate :: () => [a] -> [[a]] -> [a]

-- | The <a>findIndex</a> function takes a predicate and a list and returns
--   the index of the first element in the list satisfying the predicate,
--   or <a>Nothing</a> if there is no such element.
--   
--   <pre>
--   &gt;&gt;&gt; findIndex isSpace "Hello World!"
--   Just 5
--   </pre>
findIndex :: () => a -> Bool -> [a] -> Maybe Int

-- | Convert a single digit <a>Char</a> to the corresponding <a>Int</a>.
--   This function fails unless its argument satisfies <a>isHexDigit</a>,
--   but recognises both upper- and lower-case hexadecimal digits (that is,
--   <tt>'0'</tt>..<tt>'9'</tt>, <tt>'a'</tt>..<tt>'f'</tt>,
--   <tt>'A'</tt>..<tt>'F'</tt>).
--   
--   <h4><b>Examples</b></h4>
--   
--   Characters <tt>'0'</tt> through <tt>'9'</tt> are converted properly to
--   <tt>0..9</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; map digitToInt ['0'..'9']
--   [0,1,2,3,4,5,6,7,8,9]
--   </pre>
--   
--   Both upper- and lower-case <tt>'A'</tt> through <tt>'F'</tt> are
--   converted as well, to <tt>10..15</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; map digitToInt ['a'..'f']
--   [10,11,12,13,14,15]
--   
--   &gt;&gt;&gt; map digitToInt ['A'..'F']
--   [10,11,12,13,14,15]
--   </pre>
--   
--   Anything else throws an exception:
--   
--   <pre>
--   &gt;&gt;&gt; digitToInt 'G'
--   *** Exception: Char.digitToInt: not a digit 'G'
--   
--   &gt;&gt;&gt; digitToInt '♥'
--   *** Exception: Char.digitToInt: not a digit '\9829'
--   </pre>
digitToInt :: Char -> Int

-- | <pre>
--   comparing p x y = compare (p x) (p y)
--   </pre>
--   
--   Useful combinator for use in conjunction with the <tt>xxxBy</tt>
--   family of functions from <a>Data.List</a>, for example:
--   
--   <pre>
--   ... sortBy (comparing fst) ...
--   </pre>
comparing :: Ord a => b -> a -> b -> b -> Ordering

-- | Left-to-right composition
(>>>) :: Category cat => cat a b -> cat b c -> cat a c
infixr 1 >>>

-- | Right-to-left composition
(<<<) :: Category cat => cat b c -> cat a b -> cat a c
infixr 1 <<<

-- | <a>&amp;</a> is a reverse application operator. This provides
--   notational convenience. Its precedence is one higher than that of the
--   forward application operator <a>$</a>, which allows <a>&amp;</a> to be
--   nested in <a>$</a>.
--   
--   <pre>
--   &gt;&gt;&gt; 5 &amp; (+1) &amp; show
--   "6"
--   </pre>
(&) :: () => a -> a -> b -> b
infixl 1 &
on :: () => b -> b -> c -> a -> b -> a -> a -> c
infixl 0 `on`

-- | Flipped version of <a>&lt;$</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Replace the contents of a <tt><tt>Maybe</tt> <tt>Int</tt></tt> with a
--   constant <tt>String</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; Nothing $&gt; "foo"
--   Nothing
--   
--   &gt;&gt;&gt; Just 90210 $&gt; "foo"
--   Just "foo"
--   </pre>
--   
--   Replace the contents of an <tt><tt>Either</tt> <tt>Int</tt>
--   <tt>Int</tt></tt> with a constant <tt>String</tt>, resulting in an
--   <tt><tt>Either</tt> <tt>Int</tt> <tt>String</tt></tt>:
--   
--   <pre>
--   &gt;&gt;&gt; Left 8675309 $&gt; "foo"
--   Left 8675309
--   
--   &gt;&gt;&gt; Right 8675309 $&gt; "foo"
--   Right "foo"
--   </pre>
--   
--   Replace each element of a list with a constant <tt>String</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] $&gt; "foo"
--   ["foo","foo","foo"]
--   </pre>
--   
--   Replace the second element of a pair with a constant <tt>String</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) $&gt; "foo"
--   (1,"foo")
--   </pre>
($>) :: Functor f => f a -> b -> f b
infixl 4 $>

-- | An infix synonym for <a>fmap</a>.
--   
--   The name of this operator is an allusion to <tt>$</tt>. Note the
--   similarities between their types:
--   
--   <pre>
--    ($)  ::              (a -&gt; b) -&gt;   a -&gt;   b
--   (&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
--   </pre>
--   
--   Whereas <tt>$</tt> is function application, <a>&lt;$&gt;</a> is
--   function application lifted over a <a>Functor</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><tt>Maybe</tt> <tt>Int</tt></tt> to a
--   <tt><tt>Maybe</tt> <tt>String</tt></tt> using <tt>show</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Nothing
--   Nothing
--   
--   &gt;&gt;&gt; show &lt;$&gt; Just 3
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><tt>Either</tt> <tt>Int</tt> <tt>Int</tt></tt> to
--   an <tt><tt>Either</tt> <tt>Int</tt></tt> <tt>String</tt> using
--   <tt>show</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Left 17
--   Left 17
--   
--   &gt;&gt;&gt; show &lt;$&gt; Right 17
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; (*2) &lt;$&gt; [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <tt>even</tt> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; even &lt;$&gt; (2,2)
--   (2,True)
--   </pre>
(<$>) :: Functor f => a -> b -> f a -> f b
infixl 4 <$>

-- | raise a number to an integral power
(^^) :: (Fractional a, Integral b) => a -> b -> a
infixr 8 ^^

-- | raise a number to a non-negative integral power
(^) :: (Num a, Integral b) => a -> b -> a
infixr 8 ^
odd :: Integral a => a -> Bool
even :: Integral a => a -> Bool

-- | Extract the denominator of the ratio in reduced form: the numerator
--   and denominator have no common factor and the denominator is positive.
denominator :: () => Ratio a -> a

-- | Extract the numerator of the ratio in reduced form: the numerator and
--   denominator have no common factor and the denominator is positive.
numerator :: () => Ratio a -> a

-- | Forms the ratio of two integral numbers.
(%) :: Integral a => a -> a -> Ratio a
infixl 7 %

-- | The <a>mapMaybe</a> function is a version of <a>map</a> which can
--   throw out elements. In particular, the functional argument returns
--   something of type <tt><a>Maybe</a> b</tt>. If this is <a>Nothing</a>,
--   no element is added on to the result list. If it is <tt><a>Just</a>
--   b</tt>, then <tt>b</tt> is included in the result list.
--   
--   <h4><b>Examples</b></h4>
--   
--   Using <tt><a>mapMaybe</a> f x</tt> is a shortcut for
--   <tt><a>catMaybes</a> $ <a>map</a> f x</tt> in most cases:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; let readMaybeInt = readMaybe :: String -&gt; Maybe Int
--   
--   &gt;&gt;&gt; mapMaybe readMaybeInt ["1", "Foo", "3"]
--   [1,3]
--   
--   &gt;&gt;&gt; catMaybes $ map readMaybeInt ["1", "Foo", "3"]
--   [1,3]
--   </pre>
--   
--   If we map the <a>Just</a> constructor, the entire list should be
--   returned:
--   
--   <pre>
--   &gt;&gt;&gt; mapMaybe Just [1,2,3]
--   [1,2,3]
--   </pre>
mapMaybe :: () => a -> Maybe b -> [a] -> [b]

-- | The <a>catMaybes</a> function takes a list of <a>Maybe</a>s and
--   returns a list of all the <a>Just</a> values.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; catMaybes [Just 1, Nothing, Just 3]
--   [1,3]
--   </pre>
--   
--   When constructing a list of <a>Maybe</a> values, <a>catMaybes</a> can
--   be used to return all of the "success" results (if the list is the
--   result of a <a>map</a>, then <a>mapMaybe</a> would be more
--   appropriate):
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; [readMaybe x :: Maybe Int | x &lt;- ["1", "Foo", "3"] ]
--   [Just 1,Nothing,Just 3]
--   
--   &gt;&gt;&gt; catMaybes $ [readMaybe x :: Maybe Int | x &lt;- ["1", "Foo", "3"] ]
--   [1,3]
--   </pre>
catMaybes :: () => [Maybe a] -> [a]

-- | The <a>fromMaybe</a> function takes a default value and and
--   <a>Maybe</a> value. If the <a>Maybe</a> is <a>Nothing</a>, it returns
--   the default values; otherwise, it returns the value contained in the
--   <a>Maybe</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromMaybe "" (Just "Hello, World!")
--   "Hello, World!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromMaybe "" Nothing
--   ""
--   </pre>
--   
--   Read an integer from a string using <tt>readMaybe</tt>. If we fail to
--   parse an integer, we want to return <tt>0</tt> by default:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; fromMaybe 0 (readMaybe "5")
--   5
--   
--   &gt;&gt;&gt; fromMaybe 0 (readMaybe "")
--   0
--   </pre>
fromMaybe :: () => a -> Maybe a -> a

-- | The <a>fromJust</a> function extracts the element out of a <a>Just</a>
--   and throws an error if its argument is <a>Nothing</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromJust (Just 1)
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 2 * (fromJust (Just 10))
--   20
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 2 * (fromJust Nothing)
--   *** Exception: Maybe.fromJust: Nothing
--   </pre>
fromJust :: () => Maybe a -> a

-- | The <a>isJust</a> function returns <a>True</a> iff its argument is of
--   the form <tt>Just _</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just 3)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just ())
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isJust Nothing
--   False
--   </pre>
--   
--   Only the outer constructor is taken into consideration:
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just Nothing)
--   True
--   </pre>
isJust :: () => Maybe a -> Bool

-- | <a>uncurry</a> converts a curried function to a function on pairs.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; uncurry (+) (1,2)
--   3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; uncurry ($) (show, 1)
--   "1"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (uncurry max) [(1,2), (3,4), (6,8)]
--   [2,4,8]
--   </pre>
uncurry :: () => a -> b -> c -> (a, b) -> c

-- | <a>curry</a> converts an uncurried function to a curried function.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; curry fst 1 2
--   1
--   </pre>
curry :: () => (a, b) -> c -> a -> b -> c

-- | <tt><a>flip</a> f</tt> takes its (first) two arguments in the reverse
--   order of <tt>f</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; flip (++) "hello" "world"
--   "worldhello"
--   </pre>
flip :: () => a -> b -> c -> b -> a -> c

-- | Function composition.
(.) :: () => b -> c -> a -> b -> a -> c
infixr 9 .

-- | Identity function.
--   
--   <pre>
--   id x = x
--   </pre>
id :: () => a -> a

-- | Same as <a>&gt;&gt;=</a>, but with the arguments interchanged.
(=<<) :: Monad m => a -> m b -> m a -> m b
infixr 1 =<<

-- | Non-empty (and non-strict) list type.
data NonEmpty a
(:|) :: a -> [a] -> NonEmpty a

-- | A <a>String</a> is a list of characters. String constants in Haskell
--   are values of type <a>String</a>.
type String = [Char]

-- | A special case of <a>error</a>. It is expected that compilers will
--   recognize this and insert error messages which are more appropriate to
--   the context in which <a>undefined</a> appears.
undefined :: HasCallStack => a

-- | Boolean "and"
(&&) :: Bool -> Bool -> Bool
infixr 3 &&

-- | Boolean "or"
(||) :: Bool -> Bool -> Bool
infixr 2 ||

-- | Boolean "not"
not :: Bool -> Bool

-- | A Map from keys <tt>k</tt> to values <tt>a</tt>.
data Map k a

-- | <i>O(m*log(n/m+1)), m &lt;= n</i>. See <a>difference</a>.
(\\) :: Ord a => Set a -> Set a -> Set a
infixl 9 \\

-- | A set of values <tt>a</tt>.
data Set a

-- | A SetMap with keys <tt>k</tt> and values <tt>v</tt>.
data SetMap k v

-- | Checks whether a given number is prime.
--   
--   This function uses trial division to check for divisibility with all
--   primes below the square root of the given number. It is impractical
--   for numbers with a very large smallest prime factor.
isPrime :: Integral int => int -> Bool

-- | This global constant is an infinite list of prime numbers. It is
--   generated by a lazy wheel sieve and shared across the whole program
--   run. If you are concerned about the memory requirements of sharing
--   many primes you can call the function <tt>wheelSieve</tt> directly.
primes :: Integral int => [int]

-- | <i>O(n)</i> Convert a <a>Text</a> into a <a>String</a>. Subject to
--   fusion.
unpack :: Text -> String

-- | A space efficient, packed, unboxed Unicode text type.
data Text
(<&>) :: Functor f => f a -> (a -> b) -> f b
infixl 1 <&>
showInteger :: Integer -> String
showNatural :: Natural -> String

module Euler.Problems.Problem15

-- | The number of routes through a 20x20 grid.
answer :: Integer
countPaths :: P -> Integer
countPaths' :: Counts -> [P] -> Counts

-- | Position in the grid
type P = (Integer, Integer)

-- | Mapping from positions in the grid to the number of routes from the
--   position.
type Counts = Map P Integer


-- | In England the currency is made up of pound, £, and pence, p. There
--   are eight coins in general circulation: 1p, 2p, 5p, 10p, 20p, 50p, £1
--   (100p), and £2 (200p).
module Euler.Problems.Problem31

-- | The number of ways to make £2 using any number of coins.
answer :: Natural
ways :: Natural -> [Natural] -> Natural

module Euler.Problems.Problem47
answer :: Integer

-- | The least <i>n</i> consecutive numbers to have <i>n</i> distinct prime
--   factors.
--   
--   The first two consecutive numbers to have two distinct prime factors
--   are /14 = 2 × 7<i> and </i>15 = 3 × 5/.
--   
--   todo &gt;&gt;&gt; answerN 2 14
--   
--   The first three consecutive numbers to have three distinct prime
--   factors are <i>644 = 2^2 × 7 × 23</i>, <i>645 = 3 × 5 × 43</i>, and
--   <i>646 = 2 × 17 × 19</i>.
--   
--   todo &gt;&gt;&gt; answerN 3 644
answerN :: (Integral a, Integral b) => a -> b

module Euler.Problems.Problem9
answer :: Natural

-- | The pythagorean triple the question asks us to find. The tuple <i>(a,
--   b, c)</i> is ordered such that <i>a &lt; b &lt; c</i>.
--   
--   <pre>
--   &gt;&gt;&gt; answerTriple
--   Triple 200 375 425
--   </pre>
answerTriple :: Triple Natural
instance Data.Foldable.Foldable Euler.Problems.Problem9.Triple
instance GHC.Base.Functor Euler.Problems.Problem9.Triple
instance GHC.Show.Show a => GHC.Show.Show (Euler.Problems.Problem9.Triple a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Euler.Problems.Problem9.Triple a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Euler.Problems.Problem9.Triple a)

module Euler.Util.Arithmetic

-- | <tt>a `<a>divides</a>` b</tt> iff <i>a</i> is a divisor of <i>b</i>;
--   in other words, <i>b</i> = 0 (mod <i>a</i>).
divides :: Integral a => a -> a -> Bool

-- | <tt><a>square</a> x</tt> = <i>x^2</i>
square :: Num a => a -> a

-- | <tt><a>intSqrt</a> x</tt> is the integer <i>r</i> such that <i>r^2 =
--   x</i>, if such an integer exists.
--   
--   <pre>
--   \(NonNegative n) -&gt; intSqrt (n^2) === Just n
--   </pre>
--   
--   <pre>
--   \(Positive n) -&gt; intSqrt(n^2 + 1) === Nothing
--   </pre>
--   
--   <pre>
--   \(Positive n) -&gt; intSqrt((n+1)^2 - 1) === Nothing
--   </pre>
intSqrt :: Integral a => a -> Maybe a

-- | <tt><a>floorSqrt</a> x</tt> is the largest integer <i>r</i> such that
--   <i>r^2 &lt;= x</i>.
--   
--   <pre>
--   \(NonNegative n) -&gt; floorSqrt (n^2) === n
--   </pre>
--   
--   <pre>
--   \(Positive n) -&gt; floorSqrt(n^2 + 1) === n
--   </pre>
--   
--   <pre>
--   \(Positive n) -&gt; floorSqrt((n+1)^2 - 1) === n
--   </pre>
floorSqrt :: Integral a => a -> a

-- | <tt><a>isSquare</a> x</tt> iff <tt>x</tt> is a square.
--   
--   <pre>
--   \(NonNegative n) -&gt; isSquare (square n)
--   </pre>
--   
--   <pre>
--   \(Positive n) -&gt; not (isSquare $ (square n) + 1)
--   </pre>
isSquare :: Integral a => a -> Bool

-- | <tt><a>factorial</a> n</tt> (often written as <i>n!</i>) is the
--   product of the integers from 1 to <i>n</i>, inclusive.
factorial :: Integral a => a -> Integer

-- | All of the factorials, ascending. Equivalent to <tt><tt>map</tt>
--   <a>factorial</a> [0..]</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; take 10 factorials
--   [1,1,2,6,24,120,720,5040,40320,362880]
--   </pre>
factorials :: [Integer]

-- | One million = <i>1,000,000</i>.
million :: Integral a => a


-- | Collatz sequences are introduced in Euler problem 14.
module Euler.Util.Collatz

-- | One step of the Collatz sequence, defined for the set of positive
--   integers:
--   
--   <ul>
--   <li><i>n → n/2</i> (<i>n</i> is even)</li>
--   <li><i>n → 3n + 1</i> (<i>n</i> is odd)</li>
--   </ul>
--   
--   The example from problem 14:
--   
--   <pre>
--   &gt;&gt;&gt; takeWhile (/= 1) $ iterate collatz 13
--   [13,40,20,10,5,16,8,4,2]
--   </pre>
collatz :: Natural -> Natural

-- | <tt><a>collatzLengths</a> xs</tt> evaluates to a <a>Lengths</a>
--   mapping which contains the collatz length for at least every element
--   of <tt>xs</tt> (and possibly more).
--   
--   The example from problem 14:
--   
--   <pre>
--   &gt;&gt;&gt; collatzLengths [13] Map.! 13
--   10
--   </pre>
collatzLengths :: [Natural] -> Lengths

-- | A mapping from <i>n</i> to the length of the Collatz sequence starting
--   from <i>n</i>.
type Lengths = Map Natural Natural

module Euler.Util.ContinuedFractions
type ContinuedFraction a = (a, [a])

-- | <pre>
--   &gt;&gt;&gt; fmap (take 6) &lt;$&gt; sqrtContinuedFraction 2
--   Just (1,[2,2,2,2,2,2])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fmap (take 14) &lt;$&gt; sqrtContinuedFraction 114
--   Just (10,[1,2,10,2,1,20,1,2,10,2,1,20,1,2])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sqrtContinuedFraction 16
--   Nothing
--   </pre>
continuedFractionConvergent :: Integral a => ContinuedFraction a -> Ratio a
sqrtContinuedFraction :: Integral a => a -> Maybe (ContinuedFraction a)

-- | <pre>
--   &gt;&gt;&gt; :{
--   showRatio :: (Integral a, Show a) =&gt; Ratio a -&gt; String
--   showRatio x = intercalate "/" $ show . ($ x) &lt;$&gt; [ numerator, denominator ]
--   :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (intercalate ", ") . (fmap showRatio) . (take 5) &lt;$&gt; sqrtConvergents 2
--   Just "1/1, 3/2, 7/5, 17/12, 41/29"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (intercalate ", ") . (fmap showRatio) . (take 5) &lt;$&gt; sqrtConvergents 3
--   Just "1/1, 2/1, 5/3, 7/4, 19/11"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sqrtConvergents 16
--   Nothing
--   </pre>
sqrtConvergents :: (Integral a) => a -> Maybe [Ratio a]


-- | Dates are used in Euler problem 19.
module Euler.Util.Date

-- | <tt><a>monthLength</a> y m</tt> is the number of days in month
--   <tt>m</tt> of year <tt>y</tt>.
monthLength :: Int -> Int -> Int
monthLengths :: Int -> [Int]

-- | The number of days in a year AD.
yearLength :: Int -> Int

-- | Whether a year AD is a leap year. Leap years contain an extra day in
--   February.
leap :: Int -> Bool

module Euler.Problems.Problem19
data Date
Date :: Int -> Int -> Int -> Int -> Date

-- | Anno Domini
[dateYear] :: Date -> Int

-- | 1 (january) to 12 (december)
[dateMonth] :: Date -> Int

-- | 1 to 31
[dateDay] :: Date -> Int

-- | 1 (money) to 7 (sunday)
[dateWeekday] :: Date -> Int

-- | All dates starting from Jan 1, 1900.
datesFrom1900 :: [Date]

-- | The number of Sundays that fell on the first of the month during the
--   twentieth century (1 Jan 1901 to 31 Dec 2000).
answer :: Integer

module Euler.Util.Decimal

-- | The length of the repeating portion of a rational number's decimal
--   representation. If a decimal doesn't repeat, its repetend length is 0.
--   
--   <pre>
--   &gt;&gt;&gt; [repetendLength (1/n) | n &lt;- [1..10]]
--   [0,0,1,0,0,1,6,0,1,0]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; repetendLength (608/615) -- 0.9(88617)
--   5
--   </pre>
repetendLength :: Rational -> Int

module Euler.Util.Digit

-- | Digits of a positive integer.
digits :: (Integral a, Integral b) => b -> a -> [b]

-- | Same as <a>stringDigits</a>, for <a>Text</a> instead of <a>String</a>.
textDigits :: Text -> [Int]

-- | Get the values of numeric characters from a string, ignoring any
--   non-numeric characters.
--   
--   <pre>
--   &gt;&gt;&gt; stringDigits " 0 x0 42a"
--   [0,0,4,2]
--   </pre>
stringDigits :: String -> [Int]

-- | Maps the ten numeric ascii characters to their numeric values, and all
--   other characters to <a>Nothing</a>.
--   
--   <pre>
--   &gt;&gt;&gt; charIntMaybe '0'
--   Just 0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; charIntMaybe '9'
--   Just 9
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; charIntMaybe 'a'
--   Nothing
--   </pre>
charIntMaybe :: Char -> Maybe Int
textIntMaybe :: Integral a => Text -> Maybe a

-- | The positive integer represented by a list of digits,
unDigits :: (Integral a, Integral b) => b -> [b] -> a

-- | <tt><a>intPalindrome</a> b n</tt> indicates whether the base-<i>b</i>
--   representation <i>n</i> is a palindrome.
--   
--   <pre>
--   &gt;&gt;&gt; intPalindrome 10 &lt;$&gt; [33, 13431, 21, 335]
--   [True,True,False,False]
--   </pre>
--   
--   Zero and one are palindromes in any base.
--   
--   <pre>
--   \(Positive n) -&gt; intPalindrome (n+1) 0
--   </pre>
--   
--   <pre>
--   \(Positive n) -&gt; intPalindrome (n+1) 1
--   </pre>
intPalindrome :: (Integral a, Integral b) => b -> a -> Bool

module Euler.Problems.Problem33
answer :: (Integral a) => a
specialFractions :: (Integral a) => [(a, a)]
isCurious :: (Integral a) => (a, a) -> Bool

module Euler.Util.Fibonacci

-- | <pre>
--   &gt;&gt;&gt; take 13 fibs
--   [0,1,1,2,3,5,8,13,21,34,55,89,144]
--   </pre>
fibs :: Integral a => [a]

module Euler.Util.Foldable

-- | Whether all of the items in a list are equal.
--   
--   <ul>
--   <li>- &gt;&gt;&gt; allEqual <a>$</a> [[], [1], [1,1], [1,2]]</li>
--   <li>- [True,True,True,False]</li>
--   </ul>
allEqual :: (Foldable f, Eq a) => f a -> Bool
instance GHC.Classes.Eq a => GHC.Base.Semigroup (Euler.Util.Foldable.Aeq a)
instance GHC.Classes.Eq a => GHC.Base.Monoid (Euler.Util.Foldable.Aeq a)


-- | The string is 16 digits iff the 10 is on an external node. So we fix
--   the 10 at index 0, an arbitrary external node.
--   
--   The indices in this diagram are arbitrary, except for 0; since it
--   represents 10, it must be on the outer ring.
--   
--   0 5 1 <i> </i> 9 6 <i> </i> 4 8-7--2 3
module Euler.Problems.Problem68
answer :: String

module Euler.Util.Inf

-- | A wrapper for infinite lists, with typeclasses operating on only the
--   list's <tt>head</tt>. This is not correct in all circumstances, but is
--   useful for (for example) tails of an infinite sequence without
--   duplicate elements.
data Inf a
fromList :: [a] -> Inf a
toList :: Inf a -> [a]
instance GHC.Show.Show a => GHC.Show.Show (Euler.Util.Inf.Inf a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Euler.Util.Inf.Inf a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Euler.Util.Inf.Inf a)

module Euler.Util.List

-- | Like <tt>tails</tt>, but only the non-empty tails from a non-empty
--   list. The result is non-empty because every non-empty list has at
--   least one non-empy suffix (itself).
--   
--   <pre>
--   &gt;&gt;&gt; neTails (1 :| [])
--   (1 :| []) :| []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; neTails ('a' :| "bc")
--   ('a' :| "bc") :| ['b' :| "c",'c' :| ""]
--   </pre>
neTails :: NonEmpty a -> NonEmpty (NonEmpty a)

-- | Sublists of a fixed length.
--   
--   <pre>
--   &gt;&gt;&gt; sliding 2 "abcd"
--   ["ab","bc","cd"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sliding 3 "abcde"
--   ["abc","bcd","cde"]
--   </pre>
sliding :: Int -> [a] -> [[a]]

-- | <pre>
--   &gt;&gt;&gt; transpose ["abc","def"]
--   ["ad","be","cf"]
--   </pre>
transpose :: [[a]] -> [[a]]

-- | <pre>
--   &gt;&gt;&gt; untilNothing [Just 1, Just 2, Nothing, Just 3]
--   [1,2]
--   </pre>
untilNothing :: [Maybe a] -> [a]

-- | <tt><a>maximumOn</a> f</tt> is equivalent to <tt><a>maximumBy</a>
--   (<a>compare</a> `<tt>on'</tt> f)</tt>, but is more efficient when
--   <tt>f</tt> is costly.
maximumOn :: Ord b => (a -> b) -> [a] -> a

-- | The number of unique elements in a list.
--   
--   <pre>
--   &gt;&gt;&gt; countDistinct []
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; countDistinct "aaaaabaa"
--   2
--   </pre>
countDistinct :: (Ord a, Integral b) => [a] -> b

-- | The most common element in the list, assuming the list is nonempty and
--   has a single most common element.
--   
--   <pre>
--   &gt;&gt;&gt; mode "abbbbcc"
--   'b'
--   </pre>
mode :: Ord a => [a] -> a

-- | Remove consecutive duplicate elements from a list.
--   
--   <pre>
--   &gt;&gt;&gt; dedupe []
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; dedupe "abbbbcca"
--   "abca"
--   </pre>
dedupe :: Eq a => [a] -> [a]

-- | <pre>
--   &gt;&gt;&gt; adjustEach toUpper "abc"
--   ["Abc","aBc","abC"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; adjustEach id []
--   []
--   </pre>
adjustEach :: (a -> a) -> [a] -> [[a]]

-- | <pre>
--   &gt;&gt;&gt; adjustIndex 2 toUpper "abcd"
--   "abCd"
--   </pre>
adjustIndex :: Int -> (a -> a) -> [a] -> [a]

module Euler.Util.FrontierSearch
data Conf node value
Conf :: node -> [node] -> node -> value -> [node] -> Conf node value

-- | When node <tt>n</tt> is visited, the nodes <tt>next n</tt> are added
--   to the frontier. The new nodes must have a higher <a>nodeValue</a>
--   than the node they came from.
[next] :: Conf node value -> node -> [node]
[nodeValue] :: Conf node value -> node -> value
[start] :: Conf node value -> [node]
searchValues :: (Ord node, Ord value) => Conf node value -> [value]
searchNodes :: (Ord node, Ord value) => Conf node value -> [node]
instance (GHC.Show.Show node, GHC.Show.Show value) => GHC.Show.Show (Euler.Util.FrontierSearch.NodeWrapper node value)
instance (GHC.Classes.Eq node, GHC.Classes.Eq value) => GHC.Classes.Eq (Euler.Util.FrontierSearch.NodeWrapper node value)
instance (GHC.Classes.Ord node, GHC.Classes.Ord value) => GHC.Classes.Ord (Euler.Util.FrontierSearch.NodeWrapper node value)

module Euler.Problems.Problem11
type Grid = [[Integer]]

-- | The contents of the input file: a grid of base-10 integers delimited
--   by spaces and newlines.
type GridText = Text

-- | The greatest product of four adjacent numbers in the same direction.
answer :: GridText -> Integer
parseGrid :: GridText -> Grid

module Euler.Util.Map

-- | <pre>
--   &gt;&gt;&gt; keyWithMaxValue $ Map.fromList [('a', 4), ('b', 12), ('c', 6)]
--   'b'
--   </pre>
keyWithMaxValue :: (Ord a) => Map k a -> k


-- | English-language representations of integers, used by Euler problem
--   17.
module Euler.Util.NumberWords

-- | <pre>
--   &gt;&gt;&gt; word 21 :: Maybe String
--   Just "twenty-one"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; word 300 :: Maybe String
--   Just "three hundred"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; word 645 :: Maybe String
--   Just "six hundred and forty-five"
--   </pre>
word :: (MonadThrow m, IsString w, Semigroup (m w)) => Natural -> m w
data NumberWordException
WordUnknown :: Natural -> NumberWordException
data LetterCount
getLetterCount :: LetterCount -> Natural
instance GHC.Show.Show Euler.Util.NumberWords.LetterCount
instance GHC.Base.Semigroup Euler.Util.NumberWords.LetterCount
instance GHC.Num.Num Euler.Util.NumberWords.LetterCount
instance GHC.Base.Monoid Euler.Util.NumberWords.LetterCount
instance GHC.Classes.Ord Euler.Util.NumberWords.LetterCount
instance GHC.Classes.Eq Euler.Util.NumberWords.LetterCount
instance GHC.Show.Show Euler.Util.NumberWords.NumberWordException
instance GHC.Classes.Ord Euler.Util.NumberWords.NumberWordException
instance GHC.Classes.Eq Euler.Util.NumberWords.NumberWordException
instance Data.String.IsString Euler.Util.NumberWords.LetterCount
instance GHC.Exception.Exception Euler.Util.NumberWords.NumberWordException


-- | Pandigital numbers contain each of the digits [1..n] exactly once. For
--   example: 21, 213, and 52314 are pandigital; 0, 11, 13, and 23 are not.
--   
--   Euler problems 41 and 43 deal with pandigital numbers.
module Euler.Util.Pandigital

-- | All pandigitals, in no particular order.
pandigitals :: Integral a => [a]

-- | All pandigitals, ordered from greatest to least. The first number in
--   this list is 987,654,321, and the last is 1.
pandigitalsRev :: Integral a => [a]

-- | The 1-to-<i>n</i> pandigitals, ordered from greatest to least.
--   
--   <pre>
--   &gt;&gt;&gt; pandigitalsRevOfLength 3
--   [321,312,231,213,132,123]
--   </pre>
pandigitalsRevOfLength :: (Integral a, Integral b) => a -> [b]


-- | Pell's Equation: <i>x^2 - Dy^2 = 1</i>.
module Euler.Util.PellEquation

-- | The fundamental solution to Pell's Equation is the solution <i>(x,
--   y)</i> minimizing <i>x</i>.
fundamentalSolution :: (Integral a) => a -> Maybe (a, a)
checkSolution :: (Integral a) => a -> (a, a) -> Bool

module Euler.Util.Polynomial

-- | Polynomials are represented by coefficient lists. For example, /7 + 5x
--   - 4x^2 + 12x^4/ has coefficients <tt>[7, 5, -4, 0, 12]</tt>.
type Coefficients = []

-- | <tt><a>eval</a> cfs x</tt> is the value of the polynomial with
--   coefficients <tt>cfs</tt> at point <tt>x</tt>
eval :: (Num a) => Coefficients a -> a -> a

-- | <tt><a>hasIntRootBetween</a> cfs a b</tt> tells whether there exists
--   an integral root of the polynomial having coefficients <tt>cfs</tt> on
--   the inclusive interval <i>[a, b]</i>.
hasIntRootBetween :: (Integral a) => Coefficients a -> a -> a -> Bool

-- | <tt><a>findIntRootBetween</a> cfs a b</tt> is an integral root of the
--   polynomial having coefficients <tt>cfs</tt> on the inclusive interval
--   <i>[a, b]</i>, if one exists.
findIntRootBetween :: (Integral a) => Coefficients a -> a -> a -> Maybe a


-- | <a>Figurate numbers</a> are sets of numbers related to polygon shapes.
module Euler.Util.FigurateNumbers

-- | All of the triangle numbers, ascending.
--   
--   <pre>
--   &gt;&gt;&gt; take 5 triangles
--   [1,3,6,10,15]
--   </pre>
triangles :: Integral a => [a]

-- | <tt><a>triangleN</a> n</tt> is the <i>n</i>th triangle number.
triangleN :: Integral a => a -> a

-- | <tt><a>isTriangle</a> x</tt> denotes whether <a>triangles</a> contains
--   <tt>x</tt>.
isTriangle :: Integral a => a -> Bool

-- | All of the pentagonal numbers, ascending.
--   
--   <pre>
--   &gt;&gt;&gt; take 10 pentagonals
--   [1,5,12,22,35,51,70,92,117,145]
--   </pre>
pentagonals :: Integral a => [a]

-- | <tt><a>pentagonalN</a> n</tt> is the <i>n</i>th pentagonal number.
pentagonalN :: Integral a => a -> a

-- | <tt><a>isPentagonal</a> x</tt> denotes whether <a>pentagonals</a>
--   contains <tt>x</tt>.
isPentagonal :: Integral a => a -> Bool

-- | All of the hexagonal numbers, ascending.
--   
--   <pre>
--   &gt;&gt;&gt; take 5 hexagonals
--   [1,6,15,28,45]
--   </pre>
hexagonals :: Integral a => [a]

-- | <tt><a>hexagonalN</a> n</tt> is the <i>n</i>th hexagonal number.
hexagonalN :: Integral a => a -> a

-- | <tt><a>isHexagonal</a> x</tt> denotes whether <a>hexagonals</a>
--   contains <tt>x</tt>.
isHexagonal :: Integral a => a -> Bool

module Euler.Util.Prime

-- | <tt><a>factorizations</a> n</tt> gives the prime factorizations of
--   numbers in <tt>[1..n]</tt>. Each factorization is sorted.
--   
--   <pre>
--   factorizations 50 == Map'.fromList [(n, primeFactors n) | n &lt;- [1..50]]
--   </pre>
factorizations :: Integral a => a -> Map a [a]

-- | <pre>
--   &gt;&gt;&gt; take 9 factorizationsAsc
--   [[],[2],[3],[2,2],[5],[2,3],[7],[2,2,2],[3,3]]
--   </pre>
--   
--   <pre>
--   take 50 factorizationsAsc == (primeFactors &lt;$&gt; [1..50])
--   </pre>
factorizationsAsc :: Integral a => [[a]]

-- | This global constant is an infinite list of prime numbers. It is
--   generated by a lazy wheel sieve and shared across the whole program
--   run. If you are concerned about the memory requirements of sharing
--   many primes you can call the function <tt>wheelSieve</tt> directly.
primes :: Integral int => [int]

-- | Checks whether a given number is prime.
--   
--   This function uses trial division to check for divisibility with all
--   primes below the square root of the given number. It is impractical
--   for numbers with a very large smallest prime factor.
isPrime :: Integral int => int -> Bool

-- | <pre>
--   forAll (listOf $ elements $ take 20 primes) (\fs -&gt; primeFactors (product fs) == sort fs)
--   </pre>
--   
--   <pre>
--   \(Positive n) -&gt; isSorted (primeFactors n)
--   </pre>
primeFactors :: (Integral a, Integral b) => a -> [b]

-- | <tt><a>smallestPrimeFactor</a> n</tt> is the smallest prime factor
--   <tt>p</tt> such that <tt>p</tt> divides <tt>n</tt>.
smallestPrimeFactor :: (Integral a, Integral b) => a -> b

-- | <tt><a>largestPrimeFactor</a> n</tt> is the largest prime factor
--   <tt>p</tt> such that <tt>p</tt> divides <tt>n</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; largestPrimeFactor 2
--   2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; largestPrimeFactor 3
--   3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; largestPrimeFactor 4
--   2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; largestPrimeFactor 99
--   11
--   </pre>
--   
--   <pre>
--   forAll (elements $ take 50 primes) (\p -&gt; largestPrimeFactor p == p)
--   </pre>
largestPrimeFactor :: (Integral a, Integral b) => a -> b

-- | The divisors of a number, in no particular order.
divisors :: Integral a => a -> [a]

-- | <tt><a>countDivisors</a> n</tt> is the number of integers d from
--   <tt>[1..n]</tt> such that <tt>d</tt> divides <tt>n</tt>.
countDivisors :: (Integral a, Integral b) => a -> b

-- | The divisors of <tt><a>product</a> fs</tt>, where <tt>fs</tt> are all
--   prime, in no particular order.
divisorsOfPrimeProduct :: Integral a => [a] -> [a]

-- | The proper divisors of a number, in no particular order.
--   
--   Example from Euler problem 21:
--   
--   <pre>
--   &gt;&gt;&gt; sort (properDivisors 220)
--   [1,2,4,5,10,11,20,22,44,55,110]
--   </pre>
properDivisors :: Integral a => a -> [a]

-- | The proper divisors of <tt><a>product</a> fs</tt>, where <tt>fs</tt>
--   are all prime, in no particular order.
properDivisorsOfPrimeProduct :: Integral a => [a] -> [a]


-- | Let <i>d(n)</i> be defined as the sum of proper divisors of <i>n</i>.
--   
--   If <i>d(a) = b</i> and <i>d(b) = a</i>, where <i>a ≠ b</i>, then
--   <i>a</i> and <i>b</i> are an amicable pair and each of <i>a</i> and
--   <i>b</i> are called amicable numbers.
--   
--   Amicable numbers are defined in Euler problem 21.
module Euler.Util.Amicable

-- | <tt><a>amicableNumbers</a> n</tt> gives all of the amicable numbers on
--   the inclusive range [2, <i>n</i>], in ascending order.
amicableNumbers :: Integer -> [Integer]

module Euler.Problems.Problem69
answer :: Int
instance GHC.Show.Show Euler.Problems.Problem69.RC

module Euler.Problems.Problem46

-- | The smallest odd composite that cannot be written as the sum of a
--   prime and twice a square.
answer :: Integer

-- | All numbers that can be written as the sum of a prime and twice a
--   square, in ascending order.
--   
--   We're calling these number "goldbach numbers" after Christian
--   Goldbach; this is just made-up terminology here for lack of a better
--   word.
--   
--   <pre>
--   &gt;&gt;&gt; take 20 goldbachNumbers
--   [4,5,7,9,10,11,13,15,19,20,21,23,25,27,29,31,33,34,35,37]
--   </pre>
goldbachNumbers :: Integral a => [a]

-- | <pre>
--   take 100 squareDoubles == map (\n -&gt; 2 * n^2) [1..100]
--   </pre>
squareDoubles :: Integral a => [a]

module Euler.Problems.Problem43
answer :: Integer

-- | Three-digit substrings of the decimal representation of the input.
--   
--   <pre>
--   &gt;&gt;&gt; substrings 1406357289
--   [406,63,635,357,572,728,289]
--   </pre>
substrings :: Integral a => a -> [a]
predicate :: Integer -> Bool


-- | A number <i>n</i> is called abundant if the sum of its proper divisors
--   exceeds <i>n</i>.
module Euler.Problems.Problem23

-- | The sum of all the positive integers which cannot be written as the
--   sum of two abundant numbers.
answer :: Integer

-- | The sum of all the positive integers <i>≤ bound</i> which cannot be
--   written as the sum of two abundant numbers.
answerBounded :: Integer -> Integer


-- | This isn't a very generally-useful module, but it's included in util
--   because it's needed by both Euler problems 18 and 67 (which are
--   essentially the same problem).
module Euler.Util.TrianglePath
type Triangle a = NonEmpty (Row a)
type Row a = NonEmpty a

-- | <pre>
--   &gt;&gt;&gt; parseTriangle (T.pack " 1\n2 3")
--   (2 :| [3]) :| [1 :| []]
--   </pre>
parseTriangle :: Integral a => Text -> Triangle a

-- | <pre>
--   &gt;&gt;&gt; reduceTriangle (parseTriangle (T.pack " 1\n2 3"))
--   4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; reduceTriangle (parseTriangle (T.pack " 1\n2 3\n7 2 4"))
--   10
--   </pre>
reduceTriangle :: Integral a => Triangle a -> a


-- | The system of mapping letters to integers used by Euler problems 22
--   and 42.
module Euler.Util.WordScore

-- | Maps the letters <tt>['A'..'Z']</tt> to <tt>[1..26]</tt>,
--   case-insensitively.
--   
--   <pre>
--   &gt;&gt;&gt; map letterScore "AaBZ"
--   [1,1,2,26]
--   </pre>
letterScore :: Char -> Int

-- | The sum of the letter scores in a string.
--   
--   <pre>
--   C   o    l    i   n
--   3 + 15 + 12 + 9 + 14
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; wordScore "Colin"
--   53
--   </pre>
wordScore :: String -> Integer

-- | Same as <a>wordScore</a>, but for <a>Text</a> instead of
--   <a>String</a>.
wordScoreText :: Text -> Integer

module Euler.Problems.Problem42

-- | The number of triangle words in the input.
answer :: InputText -> Integer
parseWords :: InputText -> [Text]

-- | Whether a word's score is a triangle number.
isTriangleWord :: Text -> Bool

module Euler.Problems.Problem22

-- | The contents of the input file: a comma-delimited list of quoted
--   strings.
type InputText = Text

-- | Parse the input text for this problem.
--   
--   <pre>
--   &gt;&gt;&gt; parseNames "\"Alice\",\"Bob\""
--   ["Alice","Bob"]
--   </pre>
parseNames :: InputText -> [Name]

-- | <pre>
--   &gt;&gt;&gt; unquote "\"Alice\""
--   "Alice"
--   </pre>
unquote :: Text -> Text

-- | The answer to the problem, given the input text.
--   
--   <pre>
--   &gt;&gt;&gt; answer "\"Bob\",\"Alice\""
--   68
--   </pre>
--   
--   <pre>
--         A   l    i   c   e           B   o    b
--   (1 * (1 + 12 + 9 + 3 + 5)) + (2 * (2 + 15 + 2))
--   </pre>
answer :: InputText -> Integer

module Euler.Problems

-- | Answers to Euler problems.
--   
--   The answers to Project Euler problems are all numeric, but the type
--   here is <a>String</a> rather than <a>Integer</a> because in some cases
--   the answer is semantically a "list of digits" rather than an integer,
--   which may be an important distinction if the first digit of an answer
--   is zero.
--   
--   Most of the answers are pure, but <a>IO</a> is allowed because some
--   problems involve reading input data from files.
answers :: Map Integer (IO String)
